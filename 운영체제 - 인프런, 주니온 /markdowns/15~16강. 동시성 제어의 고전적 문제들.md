## Bounded Buffer 문제

- Producer는 Buffer를 체우고, Consumer는 비우는게 목표

- 해당 과정에서 기아, 데드락이 발생하기 쉬움

<br/>

## Readers-Writers 문제

- 프로세스들이 동시에 Shared Data에 접근하는데 어떤 프로세스들은 읽기만 할 때, 예를 들면 RDBMS에서 Read,Write가 발생할 때

- Reader는 데이터의 변경이 일어나지 않기 때문에 문제를 발생시키지 않지만, 동시에 여러 Writer가 접근하거나 동시에 Reader와 Writer가 동시에 하나의 데이터에 접근하면 동시성 문제가 발생할 수 있다.

- Reader, Writer가 공유하는 뮤텍스를 사용하거나, Reader 독자의 카운터를 별도로 관리하여 임계 영역을 제한하는 방식을 사용할 수 있다. 

<br/>

## 굶어죽은 철학자 문제

- 5명의 철학자가 각 1개의 젓가락만 가지고 식사를 하는 상황을 가정하여 공유 영역과 경쟁 상황을 가정한다.

- 이 상황에선 데드락과 기아가 발생한다. 이걸 해결하기 위해선 어떻게 해야할 것인가. (각 젓가락에 뮤텍스를 걸면 상호배제는 해결할 수 있다.)

- 가장 쉬운 방법은 철학자를 줄이는 방법(공석이 생기기 때문에 식사가 가능해진다.) 단, 늘 허용되지는 않는다.

- 두 개의 젓가락을 모두 획득한 경우에만 식사를하고 하나만 획득한 경우 다시 내려놓는다.

- 홀수는 오른쪽을 먼저, 짝수는 왼쪽을 먼저 잡는다.

- 위의 방식들은 데드락은 방지할 수 있지만, 기아를 방지하는 것은 불가능하다.

<br/>

## Thread-safe Concurrent Application

- 동시성과 좋은 성능을 만족하는 프로그램을 만들 수 있지만, 경쟁 상태와 기아 때문에 고통받는다.

- 그래서 대안으로 나오는 것들이 `thread-safe` 함수라고 하는 것들인데 이것들은 `Transactional Memory, OpenMP, Functional Programming Language(함수형 프로그래밍에선 발생하지 않기 때문에)` 등을 사용하여 구현된다.

