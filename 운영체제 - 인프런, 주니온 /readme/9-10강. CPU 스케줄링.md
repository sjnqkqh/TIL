### 개요

- Cpu 스케줄링이란, 멀티 프로세스 환경에서 N개의 프로세스를 빠르게 효율적으로 사용하기위해 CPU 자원을 분할하는 전략

- CPU burst는 작고, IO Burst가 많은 프로그램의 비율이 더 높다. 


- 메모리에 ready 상태로 적재중인 프로그램 중, 어떤 프로세스에 CPU 자원을 할당할 것인지가 문제인데 어떤 것에 자원을 할당할까

- CPU Utilization, Throughput(작업 완료 수)를 증가시키거나, Turnground time, Waiting time을 최소화 시키는 것을 목표로 한다. **Waiting Time**을 최소화하면 다른 전반적인 요소들도 좋아짐. Response time을 빠르게 만드는 것도 목적이 될 수 있다.

<br/>

### 전략 종류

- FIFO: 대기 중에 우선순위가 높은 프로세스를 찾기 어려움

- Priority Queue: 우선순위에 따라 처리하는데, 이 우선 순위를 책정하는 전략이 별도로 필요함

---

- FCFS: 먼저 온 작업 먼저 수행. 가장 간단하지만 구식이고 효율성이 낮아 더는 사용하진 않는다. 평균적인 대기 시간이 너무 길다. 선행하는 프로세스의 수행시간이 길수록 후행 작업의 대기 시간이 증가하는 형태

- SJF: 작업 시간이 짧은 작업 먼저 수행. 작업 시간을 예상하는 것은 어쨌든 정확하지 않고, 큰 작업은 아주 오랫동안 기다려야 하는 문제가 있다. 

	- 또한 미래의 사용시간을 예측하기 위해 과거의 수행시간을 기록해둬야하는데 이게 그렇게 적은 양이 아니라서 이론상 최적의 알고리즘이지만, 실제론 딱히 그렇지 않다. 

	- 구현 방식에 따라 선점(`Shortedst Remaining Time First`), 혹은 비선점으로 처리할 수 있다.

- Round Robin: 시분할. 정해진 시간만큼 동작하고 시간이 지나면 다음 프로세스로 자원 인계. 

	- 많은 운영체제에서 사용중. 보통은 시간 단위를 10~100밀리초 정도로 책정한다. 작업들은 순환 큐에 넣어서 계속 돌린다.

	- time quantum에 따라 성능이 결정된다. 이 값이 너무 크면 FCFS랑 다를게 없고, 너무 작으면 context switch로 인한 비효율이 증가한다.

- Priority-based: 우선순위에 따라 순서 책정

	- 우선 순위가 낮은 프로세스가 기아에 빠지기 쉬움. 이를 해소하기 위해 Aging을 추가하여 오래 대기중인 프로세스의 우선순위가 증가함

- Multi Level Queue: 여러번 반복적으로 time quantum을 할당하는 프로세스는 점점 더 많은 CPU 시간을 할당받는 방식. 작은 작업은 빠르게 처리되고, 큰 작업은 점점 더 많은 시간을 할당받아 context switch을 줄인다. 

<br/>

### 선점/ 비선점 전략

- 비선점: 프로세스가 CPU 자원을 할당받으면 해당 프로세스가 자원을 반환하기 전까진 외부에서 자원을 돌려받을 수 없음

- 선점: 프로세스 외의 다른 요소로 인해 자원을 반환시킬 수 있음, 현대적인 운영체제에선 대부분 이 전략을 택함

<br/>

### Dispatcher

- CPU 자원을 다른 프로세스로 넘겨주는 모듈

- context switch을 수행하는 주체

- 따라서 Dispatcher는 빠르게 동작해야 함. 이게 느리면 전반적인 작업 수행 지연속도 자체가 증가함

<br/>

<br/>

<br/>

