# 내용 전반 요약

\


#### 프록시 :

* 가짜 객체
* 객체 그래프 탐색 시 지연 로딩으로 불러오거나, 프록시를 사용하지않고 즉시 로딩해서 사용할 수 있음.
* 실제 클래스를 상속 받아서 만들어짐. 사용자는 이 객체가 실제 객체인지, 프록시 객체인지 신경쓰지 않고 사용할 수 있음
*   실제로 사용되는 시점에 데이터베이스에 조회 후, 엔티티 객체로 사용되는데 이걸 프록시 객체 초기화라고 함

    ![Untitled](assets/b5612548\_Untitled.png)
* 프록시 객체는 처음 사용할 때만 초기화된다.
* 프록시 객체를 초기화한다고 프록시 객체가 엔티티 객체가 되는 것은 아니다. 프록시 객체를 통해 엔티티 객체에 접근할 수 있게 될 뿐이다.
* 초기화는 반드시 영속성 컨텍스트의 도움을 받는다. 따라서, 준영속 상태의 프록시 객체를 초기화하면 문제가 발생한다.
*   프록시 객체는 초기화 이전에 ID 값만 가지고 있기 때문에 다음과 같이 연관9관계를 설정할 때 유용하다. 굳이 Team 객체를 초기화할 필요가 없기 때문

    ![Untitled](assets/78cba1cd\_Untitled.png)
*   하이버네이트는 엔티티를 영속 상태로 만들 때, 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라고 한다.

    ![Untitled](assets/bc12a609\_Untitled.png)
* 엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하고, 컬렉션 객체를 지연 로딩하면 컬렉션 래퍼를 동해 지연 로딩을 수행한다.
* JPA의 기본 페치 전략은 관련 엔티티가 하나라면 즉시 로딩, 다수라면 지연 로딩
* 김강사님이 추천하는 방법은 모든 관계에 지연로딩을 사용하는 것. 그리고 개발이 어느 정도 완료된 시점에 필요한 부분에 즉시 로딩을 적용하여 최적화를 진행하는 것.
* 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 컬렉션 조인은 데이터베이스 사이드에서 1:N 조인과 마찬가지인데, 이건 결국 N만큼 조인을 진행하게된다. 문제는 컬렉션이 둘 이상, 즉 2개 이상의 테이블과 조인하게 되면 N \* M 만큼 결과값이 증가하게 된다. 성능상의 악영향이 있을 가능성이 아주 높다.

![Untitled](assets/2069f2f8\_Untitled.png)

\


#### 영속성 전이

*   JPA에서 엔티티를 저장할 때 객체와 연관된 모든 객체는 영속 상태여야 한다. 따라서 Parent 객체에 포함된 childList의 객체들도 영속화가 필요한데, 이를 돕는게 영속성 전이(Cascade)

    ![Untitled](assets/5a00368e\_Untitled.png)
* 영속성 전이는 연관관계를 매핑하는 것과는 관련이 없으며, 엔티티를 영속화할 때 엔티티를 같이 영속화하는 편의성 기능이다.

\


#### 고아 객체

* JPA에서 부모 엔티티와 연관관계가 끊어진 객체를 고아객체라고 하는데, JPA에선 이 고아 객체를 DB에서 자동으로 삭제하는 기능도 갖추고 있다.

\


#### 엔티티 타입 특)

* 식별자가 있다. (@Id)
* 생명주기가 있다.
* 여러 엔티티 사이에서 참조되고 공유될 수 있다.

\


#### 값 타입 특)

* 식별자가 없다.
* 생명 주기를 엔티티에 의존한다.
* 공유하지 않는 것이 안전하다. 대신 값을 복사해서 사용할 수는 있다.
* 또한 불변 객체로 만드는 것이 안전하다.
* 따라서 정말 “값 타입”이라 싶을 때만 만드는 것이 좋다. 아니다 싶으면 엔티티로 만들어서 참조하자.

\


### JPQL

* JPA 엔티티 객체를 조회하는 객체지향 쿼리.
* 문법은 SQL과 거의 유사하고, ANSI 표준 기능들을 제공한다.
* SQL을 추상화하기 때문에 DB를 변경하더라도, 별도의 수정은 필요치 않고, dialect만 변경해주면 된다.
* 테이블이 아닌, 엔티티 객체를 기준으로 조회한다, 결국 SQL로 변환되어 DB에 날아간다.
* JPQL은 별칭을 **반드시** 사용한다.
* 쿼리를 실행하려면 쿼리 객체를 만들어야 하는데, 반환값이 명확하다면, TypeQuery, 불명확하다면 Query 객체를 사용한다.
*   JPQL API는 대부분 메소드 체인 방식으로 설계되어 있어서 아래와 같이 연속해서 파라미터를 설정할 수 있다.

    ![Untitled](assets/9c148b35\_Untitled.png)
* 파라미터 바인딩을 사용하지 않고, JPQL 쿼리를 직접 만들게되면 Query Injection에 취약해지고, DB에서 Query Parsing을 매번 진행해야해서 성능이 하락한다.
* JPQL을 통해 조회한 엔티티는 영속성 컨텍스트에서 관리된다. 1차 캐시에 저장됨
*   임베디드 타입은 스스로 조회할 수 없고, 원본 엔티티를 조회하고 그 안의 임베디드 타입을 조회하는 방식으로 컨택할 수 있다. 다만 이건 영속 컨택스트에서 관리되진 않는다. (엔티티가 아니니까…!)

    ![Untitled](assets/5801b3bf\_Untitled.png)
*   페이징은 setFirstResult(), setMaxResult() API를 통해 추상화된다.

    ![Untitled](assets/82f1d462\_Untitled.png)
* 조인도 가능하고 SQL과 유사하지만, 두 개 이상의 엔티티를 같이 조회하려면 TypeQuery 객체는 사용할 수 없다. (DTO 클래스를 만들어서 사용할 수는 있을)

#### Fetch Join

* 엔티티에 포함된 다른 엔티티나 컬렉션을 한번에 조회하기 위해 FetchJoin을 사용할 수 있다. 이 경우 함께 조회된 엔티티는 프록시 객체가 아닌 실제 엔티티이므로 원래 대상 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되더라도 함께 조회된 엔티티는 조회할 수 있다.
*   또한 엔티티에 포함된 컬렉션도 페치 조인으로 한번에 조회할 수 있다. 다만 이 경우 컬렉션 레코드를 기준으로 row가 나올 수 있다.

    ![Untitled](assets/eb3f0165\_Untitled.png)
*   때문에 이런 현상을 방지하고자 DISTINCT 옵션을 사용하여 SQL과 어플리케이션에서 중복을 제거할 수 있다.

    ![Untitled](assets/716dd3a4\_Untitled.png)

    ![Untitled](assets/c18109b9\_Untitled.png)
*   다만 이 경우 SQL만으로는 중복 제거가 명확하게 이뤄지지 않기 때문에 어플리케이션에서 한 번 더 엔티티를 기준으로 중복을 제거한다.

    ![Untitled](assets/fc448630\_Untitled.png)
* 페치 조인을 사용하지 않고, JPQL을 사용하여 INNER JOIN 처리하면 의외로 조인 엔티티는 함께 나오지 않는다. JPQL은 연관관계는 고려하지 않기 때문이다.
* 페치 조인을 사용하는건 SQL 한번으로 연관 엔티티를 함께 조회할 수 있어서 성능상 유리하다. 또한 글로벌 로딩 전략보다 상위 옵션으로 작동하기 때문에 특정 케이스에만 로딩 전략을 EAGER로 수행하는 효과를 가진다.
*   JPA 표준에선 FetchJoin 대상에 별칭을 줄 수 없지만, 구현체에 따라 가능한 경우가 있따. 다만 2차 캐시와 연계되어 연관된 데이터의 정합성이 망가질 수 있기에 사용에 주의를 요한다.

    ![Untitled](assets/7ba8b447\_Untitled.png)
*   또한 둘 이상의 컬렉션을 페치할 수는 없다. 구현체에 따라 가능하긴 한데, 컬렉션의 카타시안 곱으로 결과값이 만들어지기 때문에 주의해야한다.

    ![Untitled](assets/09a1f74e\_Untitled.png)

하이버네이트에서 2개 이상의 컬렉션을 페치 조인한 경

* 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다. 구현체에 따라 가능한 것도 있지만, 경고 로그를 남기면서 메모리에서 페이징 처리를 진행한다. 성능이 나쁘고, 메모리 초과 예외가 발생할 수 있다.
* 생각해보면 그럴 수 밖에 없는게, 쿼리 레벨에서 컬렉션이 조인으로 엮이면 레코드가 와르르 나오는게 정상이라서 페이징 처리가 불가능하지…

#### 경로 표현식

* . 으로 엔티티 내부 필드에 접근하는 방식

![Untitled](assets/5c81704c\_Untitled.png)

* 상태 필드 - 단순히 값을 저장하기 위한 필드
*   연관 필드 - 연관 관계를 표현하기 위한 필드, 임베디드 타입 포함

    * 단일 값 연관 필드 - @OneToOne, @ManyToOne
    * 컬렉션 값 연관 필드 - @OneToOMany, @ManyToMany

    ![Untitled](assets/fd56f7a7\_Untitled.png)
* 상태 필드는 한 번 접근하면 더 탐색 할 수 없다.
* 단일 값 연관 경로는 묵시적으로 내부 조인이 일어나며, 계속 탐색 할 수 있다.
* 컬렉션 값 연관 경로는 묵시적으로 내부 조인이 일어나며, 더는 탐색할 수 없다. 다만 From 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색할 수 있다.
* 컬렉션의 필드 내부에 접근하기 위해선 명시적 조인 이후 별칭을 부여하여 접근해야한다. 묵시적 조인 시 컬렉션 내부 필드엔 접근할 수 없다.
* 경로 탐색을 사용하여 나타나는 묵시적 조인은 유지보수성에 악영향을 주고, SQL이 정상적으로 작동하는지 확인하기 어렵게 만든다. 되도록 명시적 조인을 사용하는 것이 이롭다.

#### Sub Query

* JPQL의 서브쿼리는 WHERE, HAVING 절에서만 동작한다. 하이버네이트에선 추가로 select 절에서도 가능하지만, From절에선 불가능하다.

#### Named Query

*   미리 정의한 쿼리에 이름을 부여해서 사용할 수 있다. 한 번 정의하면 변경할 수 없는 정적인 쿼리. 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해둔다. @NamedQuery 어노테이션을 사용해서 자바 코드에 저장하거나 XML 문서에 저장할 수 있다.

    ![Untitled](assets/b91bbd9d\_Untitled.png)
*   자바에선 멀티라인 문자열을 다루는게 퍽 거지같기 때문에 XML을 사용하는 것도 편리하다. 특히 같은 이름의 NamedQuery가 어노테이션과 XML에 둘 다 있을 경우 XML의 쿼리가 우선적으로 선택된다.

    ![Untitled](assets/d04cf7f3\_Untitled.png)

다만 Mybatis를 사용할 때와 마찬가지로 이런 불편함이 있다…

\


***

#### Querydsl

*   어노테이션 프로세서를 사용해 쿼리 전용 클래스를 만들어서 사용함 (QMember, QAddress…)

    ![Untitled](assets/0aeac321\_Untitled.png)
* Q 클래스는 기본적으로 사용하기 편하게 기본 인스턴스를 보관하지만, 같은 엔티티를 조인하거나, 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되기 때문에 직접 다른 별칭을 지정해줘야 한다.
* import static을 활용해서 QMemeber.member를 member 로 사용할 수도 있다. (이쪽이 역시 더 편하)
* 최종적으로 uniqueResult(), singleResult(),list()를 통해 결과값을 요청할 수 있다. uniqueResult는 값이 여러 개일 경우 Error Throw, singleResult는 첫 값을 반환한다.
* listResult()는 SearchResult 객체를 반환하며, 이 안엔 totalCount나 limit, offset이 포함된다. 또한 카운팅을 위해 count쿼리를 한 번 더 날린다.
* fetch()를 사용하여 Fetch join을 수행할 수도 있다.
* 세타 조인도 가능하다. query.from(member, order)….
* JPASubQuery를 사용해서 서브쿼리를 이용 가능하다. 서브쿼리의 결과값이 다수면 list(), 하나라면 unique()를 사용한다.
*   Select 절에 조회 대상을 지정하는 것을 프로젝션이라고 한다. 조회 대상이 하나라면 해당 타입으로 반환하여 사용하면 되고, 여러 대상을 프로젝션할 땐 Tuple을 사용한다.

    ![Untitled](assets/19505834\_Untitled.png)
* 엔티티가 아닌 클래스를 대상으로 프로젝션 수행 시, Projections.bean()을 통해 조회할 수 있다. 이 때 메소드는 Setter를 통해 빈 값을 생성하기 때문에 반드시 Setter가 필요하다.
* 동일하게 fields()를 사용할 수도 있는데 이 때는 클래스 필드에 직접 접근하여 값을 세팅해준다.
* constructor()는 생성자를 사용한다. 프로젝션과 파라미터 순서가 일치하는 생성자가 존재할 때만 사용이 가능하다.
* 수정, 삭제도 할 수 있다, 다만 JPQL과 마찬가지로 영속성 컨텍스트를 무시하고 직접 DB에 쿼리를 날린다는 점에 유의해야 한다.

#### Native Query

* JPQL은 표준 SQL이 제공하는 대부분의 문법과 함수를 제공하지만, 특정 DB에 종속된 기능은 지원하지 않는다. (특정 데이터베이스 전용 함수, 문법, 힌트, 인라인 뷰, UNION, INTERSECT, stored processor)
* JPA 표준에선 쿼리 힌트를 제공하지 않지만, 구현체들중 일부는 제공한다. 특히 JPQL에서 이런 기능을 사용하려면 네이티브 쿼리를 직접 작성해야 할 수 있다.
* 다만, JDBC를 사용하는 것과 네이티브 쿼리를 사용하는데 발생하는 차이점은 JPQL을 사용했을 때 결국 이 결과값은 영속성 컨텍스트에 저장되어 관리된다는 점이다. 결국 SQL을 직접 작성한다는 점만 다르지 이후엔 JPQL과 동일하게 작동한다.
* 보통 QueryDsl이나 JPQL로 작성하기 어려운 쿼리를 사용하는 경우가 많기에, 애초에 쿼리가 복잡한 경우가 많다. 따라서 XML을 사용하여 관리하는게 더 편하다.
* 또한 JPQL에서 쿼리를 생성하는 부분’만’ 개발자가 직접 처리하는 방식이기에 JPQL에서 제공되던 다른 기능들은 정상적으로 사용이 가능하다.

\


### 객체지향 쿼리 언어 심화

* 하이버네이트, JPQL을 통해 벌크 연산을 지원한다. 다만, 영속성 컨텍스트 안에 있는 대상들을 관리하지는 않아서, 영속성 컨텍스트에 포함된 객체를 업데이트 했을 때 DB에는 업데이트가 진행되지만, 객체 상태값은 변하지 않는다.
* 해결법은 em.refresh()를 통해 Select 재호출 (비추), **벌크 연산을 가장 먼저 실행하기, 벌크 연산 이후 영속성 컨텍스트 초기화**
* 벌크 연산은 2차 캐시를 무시하고 데이터베이스에 직접 실행한다는 특징을 알고 있어야 한다.
* JPQL로 엔티티를 관리하면, 엔티티는 영속성 컨텍스트 내부에서 관리되지만, 임베디드 타입이나 단순 타입 필드는 저장되지 않는다.
* JPQL에서 조회한 엔티티가 1차 캐시에 이미 존재할 경우, 해당 엔티티는 버림 처리하고 영속성 컨텍스트의 객체를 반환한다.
  * 영속성 컨텍스트의 신규 엔티티를 하나 더 추가한다. → 영속성 컨텍스트는 PK값을 기준으로 데이터를 구분하기에 불가능
  * 기존 엔티티를 새로 검색한 엔티티로 대체한다. → 영속성 컨텍스트에서 수정된 데이터가 사라진다.
* JPQL은 조회 시, 딱히 영속성 컨텍스트를 거치지 않는다. 바로 DB에 조회한다. 따라서 조회 시 1차 캐시의 이점을 얻기 어렵다.

#### JPQL과 플러시 모드

***

JPA 플러시는 플러시 모드에 따라 아래와 같이 나뉜다.

* 커밋 시 - FlushModeType.AUTO **(Default)**
* 쿼리 실행 직전과 커밋 시 - FlushModeType.COMMIT
*   JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않기 때문에 JPQL를 실행하기 전에 영속성 컨텍스트의 데이터는 반영해주는게 좋다.

    ![Untitled](assets/955ba313\_Untitled.png)

이 경우 Flush 없이는 2000원 상품 조회에 걸리지 않는다.

* FlushMode는 기본적으로 AUTO지만, 이는 플러시가 너무 잦을 때 성능 상의 문제를 일으킬 수 있다. 때문에 성능상의 최적화를 위해 플러시 모드를 커밋으로 설정할 수도 있다. 다만 비즈니스 레벨에서 플러시를 고려한 최적화 작업이 반드시 선행되어야 한다.

![Untitled](assets/29b15a31\_Untitled.png)

![Untitled](assets/19b31b51\_Untitled.png)

![Untitled](assets/bf47cf5b\_Untitled.png)

\


### 스프링 데이터 JPA

***

![Untitled](assets/259e7c1c\_Untitled.png)

#### 쿼리 메소드 기능

* 메소드 명을 기반으로 JPQL 쿼리 생성 가능
* Named 쿼리 불러와서 사용 가능 (도메인 클래스 네임.메소드 명으로 선언된 Named 쿼리를 작동함)
* @Query 를 통해 JPQL 혹은 SQL을 실행할 수 있음
* 이 때 순서 기반 파라미터 바인딩 혹은 이름 기반 파라미터 바인딩을 통해 파라미터를 주입할 수 있음

####

페이징

* Pageable 클래스를 파라미터로 전달해서 페이징 수행 가능
* 결과값으로 Page<>, List<> 받을 수 있음
* Page 클래스 사용 시, 데이터 건 수를 조회하기 위한 count 쿼리를 추가로 호출

\


#### 사용자 정의 레파지토리

*   종종 직접 구현체를 만들어야 하는 경우도 있는데, 이럴 떈 리포지토리를 쌩으로 구현하기 보단, 사용자 정의 인터페이스를 만들고 이걸 확장하는게 백번 편하다.

    ![Untitled](assets/38005052\_Untitled.png)
* 이후 해당 인터페이스를 구현한 클래스를 만들다. 클래스 명은 반드시 인터페이스명에 Impl을 더해서 만들어야 한다. (그래야 스프링 데이터 JPA가 확장 클래스로 인식함)
* 이후, 다시 레포지토리 인터페이스에서 사용자 정의 인터페이스를 상속받으면 커스텀 인터페이스가 작동한다.

\


#### 스프링 데이터 JPA 구현체

**SimpleJpaRepository**

* Spring Data JPA에서 사용하는 구현체
* 클레스에 @Repository, @Transactional(readOnly = true) 어노테이션이 기본적으로 부여되어 있다. 여기서 @Repository는 해당 클래스가 레파지토리임을 명시하며, 또한 JPA 예외를 Spring이 추상화한 예외로 변환한다.
* 트랜잭션은 서비스 계층에서 전파 받거나 새로 생성한다. 기본적으로는 ReadOnly로 설정되어 있고, 변경이 일어나는 메소드는 별도의 트랜잭셔널 어노테이션이 달려있다.
* 데이터를 변경하지 않는 메소드에서 readOnly=true 옵션은 플러시 과정에서 약간의 성능 항상을 가져온다.

**QueryDslRepositorySupport**

* QueryDsl을 잘 사용하고 싶다면 QueryDslRepositorySupport 를 extend한 클래스를 통해 사용하는 것이 좋다.
* 또한 생성자에서 엔티티 클래스의 정보를 QueryDslRepositorySupport에 넘겨줘야 한다.

\


### 웹 애플리케이션과 영속성 관리

#### 트랜잭션 범위의 영속성 컨텍스트

* 스프링 컨테이너는 기본적으로 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
* 하나의 트랜잭션 안에선 하나의 영속성 컨텍스트에 접근하고, 트랜잭션 시작과 끝에 영속성 컨텍스트를 생성, 소멸한다.
* @Transaction 어노테이션을 통해 스프링의 트랜잭션 AOP가 먼저 동작한다.
* 트랜잭션이 종료될 때, 영속성 컨텍스트의 변경 사항이 DB에 반영된다. 이 과정에서 예외가 발생하면 롤백되고, 변경사항은 플러시 되지 않는다. 문제가 없을 경우 플러시 이후 DB 커밋이 이뤄진다.
* 엔티티 매니저는 레파지토리 마다 여러 개가 실행 될 수 있어도, 영속성 컨텍스는 트랜잭션 단위에서 관리되기 때문에, 같은 트랜잭션에 속한 여러 엔티티 매니저는 하나의 영속성 콘텍스트를 공유한다.
* 멀티 스레드 상황에서 엔티티 매니저는 공유될 수 있다. 다만, 이 경우에도 스프링 컨테이너는 스레드마다 다른 트랜잭션을 부여하기 때문에, 영속성 컨텍스트도 다른 것을 사용하게 된다. 따라서 동시성 이슈에서 자유롭다.
* 보통 서비스 계층에서 트랜잭션이 종료되기 때문에 컨트롤러와 뷰에선 엔티티가 준영속 상태로 남아있는다. 또한 지연로딩과 변경 감지가 작동하지 않기 때문에, FetchType이 Lazy인 객체를 컨트롤러나 뷰 객체에서 호출 시, 예외가 발생한다. (지연 로딩이 작동 안 해서 비어있다.)

#### N+1 문제

*   FetchType이 EAGER일 때, 리스트 객체의 수 + 1번 만큼 쿼리가 나가는 현상이 발생한다. 이 문제는 JPQL 페치 조인으로 해결할 수 있다.

    ![Untitled](assets/6e083c52\_Untitled.png)
* 다만 fetchJoin을 무분별하게 사용하면서 A, B… 처럼 메소드를 늘려나가면 프레젠테이션 계층이 데이터 계층에 의존성을 갖게된다. 이 경우 차라리 Order와 Member를 함께 Fetch Join호출하는 메소드 하나만을 두고 함께 사용하는게 나을 수 있다.
* 영속성 컨텍스트가 살아있을 때, 프레젠테이션 계층에서 필요한 엔티티를 강제로 초기화할 수도 있다. 프록시 객체는 사용하는 시점에 초기화 되기 때문에 member.getName() 이런식으로 강제로 초기화 할 수 있다. 다만 안티패턴이다. 프레젠테이션 계층의 요구가 서비스 계층의 행동을 강제하는 꼴이 되어버린다.

\


#### FACED 계층

* 프레젠테이션 계층과 서비스 계층 사이에 프록시 초기화를 위한 트랜잭션 계층을 의미한다.
* 별건 아니고 그냥 서비스 계층 코드를 호출한 이후, 결과 객체를 강제로 초기화하는 함수를 선언해서 뷰에서 호출할 수 있게 한다.
* 별로 쓸모는 없는 것 같다.

\


#### OSIV

* 영속성 컨텍스트를 프레젠테이션 계층까지 열어두는 방식. 뷰에서도 지연 로딩이 가능하다. (엔티티 그래프 탐색이 가능하다.) 이를 요청 당 트랜잭션 방식의 OSIV라고 한다.
* 문제는 요청 당 트랜잭션 방식은 프레젠테이션 계층에서 엔티티를 수정할 수 있다는 점이다.
* 이를 위해서 몇 가지 방법들이 있는데, 엔티티를 읽기 전용 인터페이스로 제공하거나, 엔티티 래핑, DTO만 반환하는 방식이다. 어쨌거나 코드는 늘어나고, 변경점을 없애느라 중복 작업이 발생한다.
*   따라서 최근에는 요청 당 트랜잭션 방식은 잘 사용하지 않고, 스프링 OSIV 방식을 주로 채택한다. ~~이제 알려주는거 봐 이 깍쟁이~~

    ![Untitled](assets/29b5a6f4\_Untitled.png)
*   스프링에서 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV다. 영속성 컨텍스트는 프레젠테이션 계층에서도 살아있지만, 수정은 불가능하다.

    ![Untitled](assets/64488537\_Untitled.png)
* 스프링 OSIV를 사용하면 서비스 계층에서 트랜잭션이 종료되고, 영속성 컨텍스트는 종료되지 않는다. 또한 영속성 컨텍스트의 모든 변경은 트랜잭션 안에서 이뤄져야한다. 때문에 트랜잭션이 종료된 이후 엔티티를 수정하고, 플러시하면 TransactionRequiredException이 발생한다.
* 대신 수정없이 지연로딩은 가능하다. 이를 트랜잭션 없이 읽기(Nontransactional reads)라고 한다.
* 스프링 OSIV는 작업 종료 이후, Flush가 아닌 close 처리한다.
* 프레젠테이션 계층 밖에서 em.flush()로 강제로 수행하려고 해도 트랜잭션 범위 밖이기 때문에 예외가 발생한다.

\


### 컬렉션과 부가 기능

* JPA에선 자바 컬렉션 중, Collection, List,Set,Map을 사용가능하다. Collection은 순서 보장X, 중복 가능 자료
* 원래는 ArrayList였던 컬렉션 필드를 영속화를 거치고 난 이후 PersistentBag으로 바꾼다. 이후 원본 컬렉션을 감싸는 하이버네이트 내장 컬렉션으로 참조를 바꿔서 관리한다.

![Untitled](assets/60de446a\_Untitled.png)

* Collection, List는 기본적으로 중복을 허용하기 때문에 add() 이후에도 딱히 지연 로딩 컬렉션을 초기화하지 않는다. 굳이 그럴 이유가 없기 때문
* Set은 중복을 허용하지 않기 때문에 add()로 추가할 때마다 equals()를 이용해서 존재여부를 확인한다. add() 실패 시 false를 반환한다.
* @Converter 어노테이션은 자바 타입을 변경해서 DB에 저장하도록 돕는 역할을 한다. 예를 들어 불린 타입 필드는 저장 시, 0,1로 저장되는데 BooleanToYNConverter를 사용해 Y,N으로 저장할 수 있다.

#### 리스너

* 모든 엔티티를 대상으로 언제 어떤 사용자가 삭제를 요청했는지 로깅하는 코드를 작성하는 건 비효율적이므로, JPA 리스너 기능을 사용하여 엔티티 생명주기에 따른 이벤트를 처리할 수 있다.

![Untitled](assets/a34e139b\_Untitled.png)

![Untitled](assets/3501a1eb\_Untitled.png)

\


### 고급 주제와 성능 최적화

#### 예외 처리

* JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스다. 또한 RuntimeException의 자식이다. 따라서 JPA 예외는 모두 UncheckedException이다.
* JPA 표준 예외는 2가지로, 트랜잭션 롤백을 표시하는 예외와 그렇지 않은 예외로 나뉜다. 전자는 심각한 예외이므로 복구해선 안 된다. 이 예외가 발생하면 강제로 트랜잭션을 커밋하더라도, RollbackException이 발생한다.
* 후자는 그렇게까지 심각하진 않다. 따라서 개발자가 용도에 맞게 커밋과 롤백을 결정할 수 있다.

![Untitled](assets/4c4ef432\_Untitled.png)

* 다만, 서비스 계층에서 데이터 접근 계층의 예외에 직접 접근하는 것은 서비스 계층이 특정 기술에 의존하게 하므로, 스프링에선 JPA 예외를 추상화하여 사용자에게 제공한다.

![Untitled](assets/23ec5281\_Untitled.png)

* JPA 예외를 스프링 프레임워크의 추상화 예외로 변경하려면 PersistenceExceptionTranslationPostProcessor를 스프링 빈으로 등록하면 된다.

#### 트랜잭션 롤백 시 주의사항

* 트랜잭션이 롤백되는 것은 엄연히 DB에서 일어나는 일이다. 따라서 변경된 엔티티까지 원본 객체로 되돌아가지는 않는다. 이런 변경 사항이 영속성 컨텍스트에 저장되어있다가 다른 트랜잭션에서 커밋되면 아주 곤란할 수 있기에, 새로운 영속성 컨텍스트를 생성하거나, em.clear()를 통해 초기화해야 한다.
* 기본적으로 트랜잭션 당 영속성 컨텍스트 전략은 트랜잭션이 끝나면 영속성 컨텍스트도 종료되기에 문제가 없지만, OSIV 같은 걸 사용하면 명시적으로 초기화해야한다.

\


#### 엔티티 비교

* 동일한 영속성 컨텍스트 안에서 ID가 같은 값은 동등하며, 또한 동일한 주소값을 같는다. ojb1 == ojb2가 참이 된다.
* 결국 1차 캐시의 가장 큰 장점인 **애플리케이션 수준의 반복 가능한 읽기**를 지원하는 것
* 예를 들어서, Test에서 @Transactional 을 통해 트랜잭션을 선언하고, MemberRepository에 1L로 접근해서 얻은 엔티티와, 테스트 내부에서 MemberService를 통해 1L로 얻어낸 엔티티는 완전히 동일한 엔티티다.
* 참고로 테스트 메소드에 트랜잭션 어노테이션을 사용하면 트랜잭션 종료 시, 커밋을 수행하지 않고 롤백하기에 때문에 내부에서 어떤 SQL이 실행되는지 알 수 없다. 따라서 필요하다면 em.flush를 통해 명시적으로 처리해줘야 확인이 가능하다.
* 준영속 상태의 엔티티와 영속 상태의 엔티티는 ID 값이 같더라도 다른 객체로 처리된다. ojb1 ≠ obj2
* 다른 엔티티 컨텍스트의 객체를 비교할 때는 비즈니스 키를 활용한 동등성 비교가 권장된다. 다만 이 키들은 반드시 유일성이 보장되어야 한다.

\


#### 프록시 심화

* 하나의 영속성 컨텍스트 안에서 em.getReference()를 통해 프록시 객체를 먼저 조회하고 em.find()를 통해 원본 엔티티를 조회하면 두 객체는 동일한 프록시 객체다.
* 반대 순서로 조회 시, 두 객체는 동일한 원본 엔티티이다. 1차 캐시에 저장되어 있는건 굳이 조회하지 않고, 프록시 객체가 저장되어 있더라도 마찬가지로 DB 조회를 거치진 않기 때문
* 프록시는 원본 엔티티를 상속받아 만들어지기 때문에 이것이 원본 객체인지, 프록시인지 신경쓰지 않고 사용할 수 있었지만, 가끔 문제가 발생하기도 한다.
* 예를 들어 프록시의 클래스와 원본 엔티티의 클래스를 동일성 비교 == 하면 false가 나온다. 프록시 클래스는 원본 엔티티 클래스를 상속한 별개의 클래스이기 때문에. 따라서 비교시 `proxyMember instanceof Member` 처럼 `Instanceof` 비교 해줘야 한다.
* 또한 equals() 함수는 자동 완성 시, 클래스 동일성도 비교하는데 이로 인해 원본 엔티티와 프록시의 동등성이 불일치한다고 나온다. 따라서 이 부분은 프록시 객체를 고려하면 명시적인 수정이 필요하다.
*   또한 상속 관계가 있는 엔티티의 부모 엔티티를 프록시로 조회하면 문제가 생길 수 있다.

    ![Untitled](assets/396c648c\_Untitled.png)

    이 경우 proxyItem은 Item을 상속한 **프록시 클래스 객체**이기 때문에 Book 클래스와는 전혀 연관관계가 없는것. 따라서 저 조건문은 그냥 지나가버린다. 또한 조건문을 실행한다고 하더라도 Book으로 다운그레이드가 불가능하기 때문에 ClassCastException 예외가 발생한다.
* 프록시 객체를 실제 엔티티로 변경하기 위해선 JPQL을 통해 대상을 직접 조회하거나, 하이버네이트가 제공하는 프록시 해제 기능을 사용할 수 있다.
* 혹은 기능을 위한 별도 인터페이스를 만들어서 상속한 이후, 해당 기능을 각 클래스 별로 구현하거나 Visitor 패턴을 통해 프록시를 실체화시키고, 특정 기능을 실행시킬 수 있다.

### 성능 최적화

#### N+1

* JPQL이 실행되면 JPA는 FetchType은 신경쓰지 않고, JPQL을 이용해서 SQL을 생성한다. 만약 `SELECT * FROM MEMBER` 이런게 실행된다면 EAGER로 설정된 필드는 전부 로딩된다. 이 떄 N+1문제가 발생한다.
* 지연로딩으로 변경하더라도 N+1 문제에서 자유로울 수는 없다. 지연로딩으로 설정하더라도 List를 순회하면서 연관 컬렉션을 조회하는 로직에서 N+1 문제는 발생한다. 회원의 수 만큼 SQL이 더 발생하는 거다.

***

#### N+1 회피 방법

*   Fetch Join

    ![Untitled](assets/ce627176\_Untitled.png)

    * 이 예제는 1대다 조인을 사용하여 중복된 결과가 나올 수 있으므로 DISTINCT 키워드를 사용하여 중복을 제거해야한다.
*   Hibernate — `@BatchSize`

    ![Untitled](assets/cae62ea6\_Untitled.png)

    * 하이버네이트가 제공하는 어노테이션을 통해, 특정 필드를 조회할 떄 지정한 size만큼 SQL의 IN절을 사용해 조회한다. IN 절이 성능상 좋은 편은 아니지만 N+1 문제가 발생하는 것보단 낫다.

\


*   Hibernate — `@Fetch`

    ![Untitled](assets/ea71d5f9\_Untitled.png)
*   해당 어노테이션 적용 시, EAGER라면 엔티티 조회 시, LAZY라면 지연 로딩된 엔티티 사용시 Subquery를 사용하여 초기화한다.

    ![Untitled](assets/3d47e618\_Untitled.png)

***

#### N+1 결론

* FetchType.EAGER는 쓰레기다. 대상 컬럼이 다수인 경우엔 Lazy로 두고 사용하고, 필요에 따라 FetchJoin을 통해 최적화하도록 하자.

***

#### 읽기 전용 트랜잭션

* JPA는 기본적으로 변경 감지를 지원하기 때문에, 엔티티 조회 시 스냅샷을 별도로 보관한다. 때문에 메모리 자원의 사용량의 증가하게 되는데, 읽기 전용 트랜잭션으로 선언한다면 별도의 스냅샷을 저장하지 않기 때문에 메모리 효율성이 증가한다.
* 또한 스프링의 @Transactional(readonly = true)를 사용한 경우, 스프링이 하이버네이트의 플러시 모드를 MANUAL로 변경하여, 명시적으로 플러시를 수행하지 않는한 플러시가 일어나지 않는다. 단, 트랜잭션을 사용하는 것은 변하지 않으므로, 트랜잭션 시작, 로직 수행, 커밋은 이뤄진다. 단지 영속성 컨텍스트의 플러시가 일어나지 않을 뿐이다.

\


***

#### 배치 처리

* 엔티티를 초기화 없이 계속 조회하면 메모리가 터져나간다. 작업 단위가 큰 배치 작업에서 이런 일이 일어날 수 있는데, 이 때는 적절히 영속성 컨텍스트를 초기화해야한다. 또한 2차 캐시에 엔티티를 보관하지 말아야한다.
* 배치 등록 시엔, 일정 크기마다 영속성 컨텍스트를 플러시하고, clear()해야 한다.
* 수정 배치 시엔 일이 좀 다르다. 기본적으로 DB에서 엔티티를 긁어오고 수정해야 하기 때문에 메모리에 엔티티를 올려야한다. 주로 데이터베이스의 `Paging` 기능을 사용하거나, `Cursor` 기능을 사용한다.
*   `DB Paging 기능을 사용하는 배치 처리 예시`

    ![Untitled](assets/6624176a\_Untitled.png)
* JPA는 JDBC Cursor를 지원하지 않기 때문에, 하이버네이트 세션을 얻어내서 사용해야한다.
*   `하이버네이트 세션 unwrap - scroll`

    ![Untitled](assets/19ab445e\_Untitled.png)

    ![Untitled](assets/4e570bcd\_Untitled.png)
*   `하이버네이트 무상태 세션 사용`

    무상태 세션은 영속성 컨텍스트를 만들지 않고, 2차 캐시도 기본적으로 사용하지 않는다. 다만, 영속성 컨텍스트가 없기에 수정 시 session의 update()를 호출하여 갱신해줘야 한다.

    ![Untitled](assets/b225c3b4\_Untitled.png)

    ![Untitled](assets/22d8562d\_Untitled.png)

    \


\


#### 힌트

* JPA는 SQL 힌트를 제공하지 않기 때문에 하이버네이트를 직접 사용해야한다.
* 다만 하이버네이트 4.3.10 버전 기준 오라클 방언만 힌트가 적용되어 있어 다른 데이터베이스에서 힌트를 사용하려면 org.hibernate.dialet.Dialect에 있는 각 방언에서 getQueryHintString()를 오버라이딩 하여 구현해야한다.

\


#### 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치

* 네트워크 한 번 호출 비용 >>> 단순 메소드 수 만 번 호출 비용
* 하이버네이트에선 SQL 배치 기능을 지원하므로 이를 활성화해서 쓰기 지연을 실행할 수 있다.

![Untitled](assets/7926b14f\_Untitled.png)

* 다만, 식별자 생성 전략이 IDENTITY인 경우엔, 엔티티를 데이터베이스에 저장해야만 식별자를 구할 수 있으므로 em.persist를 호출하는 즉시 INSERT 쿼리가 날아간다. 때문에 이 방식을 통한 쓰기 지연은 불가하다.
* 쓰기 지연은 다른 것보다 DB Lock을 최소화하는데 의의가 있다. 일반적인 트랜잭션에선 중간에 업데이트가 이뤄진 경우 트랜잭션이 종료될 때까지 해당 로우에 비관적 Lock이 걸린다. 하지만 JPA 쓰기지연은 업데이트 쿼리가 날아가고 곧장 커밋이 일어나는 효과를 낸다. 따라서 동시간 내에 더 많은 트랜잭션 처리가 가능해진다.

\


#### 트랜잭션 격리 레벨

* READ UNCOMMITED
  * Dirty read 발생함. 커밋 안 했는데 조회해뿌림
* READ COMMITED
  * 트랜잭션 중간에 읽고 있던 데이터의 값이 변할 수 있음 (Non-Repeatable read)
* REPEATABLE READ
  * 트랜잭션 중간에 결과 집합이 달라질 수 있음. (쿼리 조건에 해당할 경우 처음에 없던 데이터가 추가 될 수 있음, Phantom read)
*   SERIALIZABLE

    * 동시 트랜잭션 처리 속도가 떨어짐, 아노말리 X

    ![Untitled](assets/46fda02b\_Untitled.png)

    \


**낙관적 락**

* 트랜잭션 대부분은 충돌이 일어나지 않는다는 가정 하에 락을 제어하는 방식. 데이터베이스가 제공하는 락을 사용하지 않고, JPA가 제공하는 락을 사용한다.

**비관적 락**

* 트랜잭션 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방식. 데이터베이스의 락을 사용한다. SELECT FOR UPDATE 처럼 해당 레코드에 락을 건다.

**두번의 갱신 분실 문제**

* 두 명의 사용자가 하나의 공지사항을 순서대로 수정 후 커밋했을 때, 마지막 내용만 커밋되는 문제

![Untitled](assets/ffbdcdff\_Untitled.png)

* 때때로 최초 커밋만 인정하는 방식을 택할 수 있는데 이 떄 JPA의 버전 관리 방식을 사용할 수 있다.
* @Version. JPA 엔티티의 버전 관리 필드에 사용할 수 있다. Long, Short, Integer, Timestamp 사용 가능. 엔티티가 수정될 때 마다 자동으로 증가한다.\*\* 엔티티를 수정할 때와 조회 시점의 버전이 다르다면 예외가 발생한다\*\*.
* 따라서 버전에 따라 최초 커밋 인정하기가 적용된다.
* 버전은 엔티티값을 변경하면 증가하고, 임베디드 타입과 값 타입 컬렉션은 논리적으로 엔티티 필드이므로 수정되면 버전이 증가한다. 다만, 외래 필드의 값은 변경되어도 버전이 증가하진 않는다.
* 벌크 연산은 버전을 증가시키지 않는다.

#### JPA LOCK

* JPA 락은 버전이 있어야 사용 가능하다. 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다. 별도의 락 옵션 없이도 @Version만으로 낙관적 락은 적용된다.
* @Optimistic 을 추가하면 엔티티를 (수정없) 조회만 해도 버전을 체크한다. Dirty Read랑 Non-Reaptable read를 방지한다. 이 경우 트랜잭션 격리 레벨이 Read-Commit이어도, Repeatable Read로 동작한다.
* 비관적 락은 데이터를 수정하는 즉시 알 수 있으며, 쿼리를 SELECT FOR UPDATE 구문을 이용하면서 시작한다. 주로 PESSIMISTIC\_WRITE 모드를 사용한다. Non-repeatable read를 방지한다.
* RESSIMISIC\_READ. 데이터를 읽기만하고 수정하지 않는 용도로 사용하며, 일반적으론 잘 사용하지 않는다.

\


#### 2차 캐시

* 네트워크를 통해 DB에 접근하는 비용은 메모리에 접근하는 것보다 수만 \~ 수십만 배 비싸기 때문에 최적화 우선순위가 높은 작업이다.
* 영속성 컨텍스트 내부에 엔티티 보관 공간은 1차 캐시, 애플리케이션 범위의 캐시를 2차 캐시라고 한다.
* 1차 캐시는 끄고 켤 수 있는 옵션이 아니다.
* 2차 캐시는 애플리케이션 스코프에서 작동하는 캐시로, 애플리케이션을 종료할 때까지 유지되며, 분산 캐시나 클러스터링 환경의 캐시는 더 오래 유지될 수 있다.
* 2차 캐시는 동시성을 극대화하기 위해 캐시한 객체를 직접 반환하지 않고 복사본을 반환한다.
  * 2차 캐시는 영속성 유닛 범위의 캐시다.
  * 2차 캐시는 복사본을 반환한다.
  * 2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만, 영속성 컨텍스트가 다르다면 객체 동일성을 보장하지는 않는다.
* 2차 캐시를 사용하려면 @Cacheable 어노테이션을 사용하면 된다. 옵션으로 boolean 값을 넣을 수 있는데 기본적으로 true다.
* persistence.xml에서 캐시 모드를 설정할 수 있으며, 기본적으론 ENABLE\_SELECTIVE를 사용한다.

![Untitled](assets/b0aa6df9\_Untitled.png)

\


#### 하이버네이트 EHCACHE

**하이버네이트 캐시 종류**

1. 엔티티 캐시 - 엔티티 단위로 캐시한다. 식별자로 엔티티 조회 시 사용 (JPA 표준엔 얘만 정의되어 있다.)
2. 컬렉션 캐시 - 엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다.
3. 쿼리 캐시 - 쿼리와 파라미터 정보를 키로 사용해서 캐시한다. 결과가 엔티티면 식별자 값만 캐시한다.

* @Cacheable : 엔티티를 캐시하려면 사용한다
* @Cache : 하이버네이트 전용으로, 캐시에 대해 더 세밀한 설정을 할 때 사용한다. 또한 엔티티 필드에 컬렉션 캐시를 저장하기 위해서 사용할 수도 있다. 엔티티와 엔티티 내부의 컬렉션 필드에 사용 가능.

\


**@Cache**

*   속성으로 usage, region, include를 포함하며, usage 속성은 캐시 동시성 전략을 설정할 수 있기에 중요하다.

    ![Untitled](assets/d95f54cb\_Untitled.png)

    ![Untitled](assets/ea6cf4a8\_Untitled.png)
* 2차 캐시 기능 중, Query Cache와 Collection Cache를 사용할 땐 반드시 Entity Cache기능을 사용해야한다.
* 쿼리 캐시와 컬렉션 캐시는 엔티티 ID만을 저장하는데, 이 때 Entity Cahce를 사용하지 않으면, 이 모든 ID값을 DB에서 조회해야한다. 이는 성능 상의 극심한 하락을 가져온다.
