# 6장. 스프링이 사랑한 디자인 패턴

* 디자인 패턴은 객체 지향의 특성 중 상속, 인터페이스, 합성(객체를 속성으로 사용)을 이용한다. 이 세 가지 방식 외에 다른 방식은 없다. ~~그래요..?~~

### 어댑터 패턴

_호출 당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴. Like `JDBC` - 204page_

* 대표적으로 JDBC가 있다. DB 바꿀 때 드라이버만 갈아끼우면 되고 사용하는 인터페이스는 동일하다.
* OCP를 디자인 패턴으로 녹여 놓은 케이스

### 프록시 패턴

* 프록시는 대리자, 대변인이라는 뜻을 갖는다.
*   프록시 패턴은 인터페이스를 사용해, 실제 클래스와 동일한 메서드 시그니쳐를 포함하는 메서드를 갖는다.

    프록시 패턴의 주요 포인트
* 프록시 패턴은 실제 메서드의 입력값, 그리고 반환값을 동일하게 전달한다. 프록시 패턴의 목적은 제어 흐름을 조정하기 위해 사용된다. 로깅 로직을 추가하거나 뭐 그런 용도면 적합하다.
* 책에는 기술되지 않았지만 JPA Entity의 프록시 객체도 대표적인 프록시 패턴이다. 실제 객체와 동일한 인자, 반환값을 갖는 프록시 객체를 통해 엔티티를 제어하는 점에서 그러하다.

### 데코레이터 패턴

* 프록시 패턴과 유사하지만 반환값에 변형을 가한다는 점에서 다르다.

### 싱글턴 패턴

* 인스턴스를 하나만 만들어서 사용하기 위한 패턴
* 커넥션 풀, 스레드 풀 객체 등은 여러 개를 만들었을 때 오히려 예상하지 못한 결과를 낳을 수 있고 불필요한 자원을 할애하게 된다.
* 싱글턴 패턴을 위해선
  * 생성자를 private로 선언하고
  * 유일한 단일 객체를 반환하는 정적 메서드가 필요하며
  * 유일한 단일 객체를 참조할 정적 참조 변수가 필요하다.
* 단일 객체는 속성 (필드)를 갖지 않는게 국룰이다. 아니면 읽기 전용 필드를 갖던가

### 템플릿 메서드 패턴

* 상위 클래스에서 공통적인 로직을 수행하는 메서드를 선언하고, 하위 클래스에서 구현해야하거나 Override 할 수 있는 (Abstract, Hook) 메서드를 두는 패턴이다.
* 중심이 되는 내용은 공통된 동작을 템플릿으로 빼고, 각 클래스 별로 다르게 동작하는 부분을 개별로 구현하게 두는 것이다.

### 팩터리 메서드 패턴

* 간략하게 얘기해서 Override한 메서드가 반환한 객체를 사용하는 패턴
* 그림 6-10의 `FactoryMethodPattern.AnimalToy`를 확장한 구현체 `CatToy, DogToy`에서 `identify()`를 확장하고, 해당 메서드의 반환값을 클라이언트에서 사용한다.

### 전략 패턴 (Strategy Pattern)

* 자바에선 단일 상속만 가능하기에 상속이라는 제한이 있는 템플릿 메서드보다 전략 패턴이 더 많이 활용되는 경향이 있다.
* OCP와 DIP가 적용된 것을 알 수 있다.
  * runStrategy()만 열려있고 이를 구현체에서 정의한다 → OCP
  * 각각의 구현체가 아닌 인터페이스를 참조한다 → DIP

### 템플릿 콜백 패턴

* 전략 패턴과 유사하지만 전략을 생성하는 코드가 외부 클래스가 아닌 컨텍스트 내부로 편입되는 형태
* 전략패턴에서 별도 클래스에 전략을 구현하고, 클래스를 갈아끼워 전략을 교체하는 형태에서, 컨택스트에 인자를 전달하여 전략을 교체하는 형식으로 변경되었다.
* 저자는 한 문장으로 \*“전략을 익명 내부 클래스로 구현한 전략 패턴”\*이라 정의했다.
