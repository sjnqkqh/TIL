# 내가 만난 인생 최악의 코드들 - SQL 지옥

개발자로 일하다 보면 많은 경우 누군가가 만들어놓은 프로젝트 위에서 작업을 진행합니다.

때로는 너무 오랫동안 개발/유지되면서 레거시가 가득한 코드를 만나기도 하고, 때로는 혼동을 일으키는 주석이 달려있거나, 코드를 지우지 않고 나중에 다시 쓸 수도 있어서 주석처리 해놓은 코드들을 만나기도 합니다.

때로는 아주 성의없는 네이밍을 마주 치기도 하고, 복잡한 코드도 많습니다.

그 중, 제가 몇 년간의 커리어 중 마주친… 최악의 프로젝트 2개를 소개해보겠습니다!

![](assets/d58a76fd_image.png)

주의! 개인적인 원한이 쪼금 담겨있는 포스팅입니다. 최악의 프로젝트를 소개하는 만큼 조금만 양해를 부탁드리겠습니다…

\


***

### 왜 SQL 파일 하나에 집착하는 건가요…

2023년. ORM은 이미 충분히 검증되고 대중화된 기술이었고, 많은 프로젝트들이 ORM을 기반으로 구현되거나 기존 프로젝트에 접목되는 방향으로 적용되고 있었습니다.

* 서버 개발자들이 SQL을 익히기 싫어서 혹은 어려워서 ORM을 쓴다
* 어떤 사람은 ORM으로 테이블을 구축한다더라
* 어떤 사람은 실수로 데이터베이스를 싹 날려먹었더라

등 우려섞인 목소리도 있었지만 (~~사실 모두 한 사람이 한 말입니다.~~) 그래도 기술적으로 괜찮은 선택지임에는 틀림없다 생각합니다. ORM을 통해 기존의 Query Mapper보다 자연스럽게 코드에 SQL문을 녹여낼 수 있었고, 이는 좀 더 작고, 좀 더 정돈된 코드를 작성하기에 좋은 기술이었으니까요!

하드웨어의 발전으로 인해, 개발환경에서도 예전처럼 성능이 가장 중요하기보단, 적당한 성능을 유지하는 선에서 개발 속도 및 유지보수 난이도가 낮은 코드, 회귀 버그를 막기 위한 테스트 코드를 포함한 코드 등이 더 중요해졌습니다. 이를 위해 함수와 클래스는 작은 범위에서 각자의 책임만을 수행하는 형태로 변해왔습니다. 작을 수록 이해하고 수정하기 쉽거든요.

#### **하지만!**

![](assets/5f54d117_image.png)

이 모든 흐름을 모두 역행하고, **하나의 API는 하나의 SQL 파일로 실행하도록 구현해야 한다.** 는 확고한 신념을 가진 ~~최악의~~ 개발자가 ~~하필이면 백엔드팀에 저랑 단 둘이~~ 한 명 있었습니다.

회원가입 기능이 있다고 할 때 제게 익숙한 Service 레이어의 모습은 대략 아래와 유사합니다. 각 기능은 함수가 맡은 역할과 책임을 수행하며 분리된 형태입니다.

```javascript
function createUser(dto){
	validateParameter(dto);
	idDuplicationCheck(dto.loginId)
	checkValidationCode(dto.validateCode)
	....
	createUser(dto)
}
```

사실 많은 개발자분들께 익숙한 형태일 거라고 생각합니다. 보편적이기도 하구요. 하지만 최악의 코드는 보법부터 달랐습니다…

\


***

#### 최악의 코드는 이런 식으로 생겼어요.

그 분이 강요한 프로젝트 코드의 형태는 아래와 같았습니다.

아래 코드는 예시를 위해 작성된 샘플 코드로, 실제 프로덕트의 코드가 아닙니다!

```javascript
/**
 * cbs0004 회원가입
 */
router.post('/signup', httpUtil.checkParam(schema.cbs0025), async function (req, res, next) {
	try {
		let param = [stringify(req.body)];
		let rows = await rdb.queryFile('sql/v1/user/cbs0025.sql', param);

		res.json({
			user_no: rows[20][0].user_no,
			co_no: rows[20][0].co_no,
		});
	} catch (err) {
		let result = errors.getError(err);
		res.json(result); // HTTP CODE 200
	}
});
```

\


**제가 이런 코드 형태를 최악으로 꼽는 이유는 아래와 같습니다.**

* Service Layer가 없이 End Point에서 쿼리 파일 하나를 읽어서 비즈니스 로직을 전개합니다. 이로 인해 하나의 API 구현에 따르는 결합성이 과도하게 높아집니다. 이는 추후 수정 및 유지보수 상황에서 일부 로직의 수정이 다른 부분에 까지 영향을 미쳐 에러 발생 가능성을 높입니다.
* rows 변수는 해당 SQL 파일에 포함된 각 쿼리의 실행 결과입니다. 해당 파일은 총 20개의 개별 쿼리로 이뤄져있으며, 이를 index로 접근하여 결과를 반환합니다. 중간에 쿼리가 추가/제거되면 인덱스는 하나씩 밀립니다.
* 각 API마다 달려있는 의문의 API Code… 왜 이런 짓을 하는걸까요…
* Error가 발생한 케이스에도 HTTP Response code는 200입니다. 왜…?
* 모든 API EndPoint에 동일한 try/catch문이 보일러 플레이트로 들어갑니다. 이 부분은 Express.js의 미들웨어를 통해 해결할 수 있습니다.

\


**하지만 가장 나쁜 점은** **이제 시작입니다.**

```sql
# cbs0004 회원가입
SET @data       = ?;  #0
SET @dup = 0; # 1
SET @co_no = null; # 2
SET @user_no = null; #3
SET @adsgrp_no = null; # 4

-- Error Check

# 5 
SELECT count(1)
  INTO @dup
  FROM tbuser
 WHERE id <=> JSON_EXTRACT(@data, '$.id')
   and ws_no = JSON_EXTRACT(@data, '$.ws_no')
;

#6
IF (@dup > 0) THEN
	SIGNAL SQLSTATE '91006'; # DUPLICATE_ID
END IF;

#7
START TRANSACTION;

# 8
INSERT INTO user
   SET id			= JSON_EXTRACT(@data, '$.id')
   ...

# 12
IF @type = 'CE' THEN
...
ELSE IF @type = 'VW'
...
END IF;

# 15
@seq = 0; #16
@length = JSON_LENGTH(@term_list); #17
WHILE(@seq < @length) DO
...
	SET @seq = @seq+1; #18

END WHILE;
...

# 20
SELECT *
FROM tbuser u
JOIN tbuser_term ut
JOIN nmms m
JOIN tbtows t
JOIN (SELECT ...) a
...
```

위 파일에서 나타나는 문제점은 다음과 같습니다.

* 조건문, 반복문을 쿼리로 처리하다보니 문법이 지난하다.
* 파라미터 대입을 ?에 처리한다. →
* SQL 파일 하나에서 모든 로직을 처리하면서 Debuger를 사용할 수 없게됐다. 디버깅 모드는 SQL 파일 내에서 작동하지 않는다.
* Table Alias를 너무 축약하여 작성하여 다른 사용자로 하여금 해당 코드가 무슨 의미인지 이해하기 어렵게 만든다.
* 모든 로직이 순차적으로 처리되어 중간에 다른 로직을 구성하거나 변경하기 힘들다.
* 또한 변경 사항이나 문제가 있을 때, 해당 파일 내의 어떤 부분이 수정의 대상이 되어야하는지 알기 어렵다.
* 모든 쿼리에 인덱스를 써줘야 한다… + 중간에 쿼리가 추가되면 인덱스가 밀립니다.
* 테이블 명은 왜 또 저 모양일까요. `nmms`가 대체 뭔데…

\


싸우고, 말려도 봤지만 고집을 꺾지 못한 나머지 어느 순간 예시 코드처럼 작성된 API는 100개 가량 넘었습니다.

![](assets/909b5fd8_image.png)

차마 2023년에 시작된 프로젝트라고는 생각하기 어려운 형태의 코드는 쌓여갔고, 제가 ~~**미친**~~\*\* 티라노\*\*라고 부르는 프로덕트는 그렇게 완성됐습니다.

***

#### 그래서 지금은…?

현재도 해당 프로젝트는 유지보수 중입니다.

![](assets/00a252cc_image.png)

마음같아서는 싹 내다버리고 다른 언어 + 프레임워크 기반으로 다시 만들고 싶었으나, 현실적인 이유로 여의치 않았고, 최근 Prisma ORM을 도입하여 신규 기능 구현 + 유지보수 중입니다. Service Layer를 추가하고, 기능별로 함수를 나누고, 다른 개발자가 봐도 편하게 이해할 수 있도록 작은 함수의 합으로 하나의 기능을 구성하고 있습니다.

당연한 일을 위해 장족의 발전이 필요했네요. 그래도 점점 나아지고 있습니다. 최근, **기능적으로 가장 다루기 어려운 상품 결제 기능도 ORM 기반으로 전환이 완료되었거든요!** 앞으로도 점점 나은 코드가 되도록 개선해볼 예정입니다.

다소 불만이 가득한 포스팅이지만 끝까지 읽어주셔서 감사합니다. 다음 포스팅에선 SI 외주 결과물로 받은 최악의 코드를 소개해드리겠습니다!
