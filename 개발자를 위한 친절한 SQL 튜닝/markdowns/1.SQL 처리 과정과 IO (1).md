# 1.SQL 처리 과정과 IO

#### SQL 처리 순서

1. SQL 파싱
2. SQL 최적화 (Optimizer)
3. 로우 소스 생성

\


#### SQL 옵티마이저

* 사용자가 입력한 작업을 가장 효율적으로 처리할 수 있도록 처리하는 핵심 엔진
* 데이터 딕셔너리에서 미리 수집한 통계를 이용해 실행 계획과 예상 비용을 산정한다.
* 그 중에 제일 싼 걸로 실행한다.

\


#### I/O 매커니즘

* 테이블 스페이스 > 세그먼트(테이블, 인덱스) > 익스텐트 > 블록
* 하나의 익스텐트는 연속된 블록의 집합으로 되어있고, 하나의 세그먼트는 같은 테이블 익스텐트로 이뤄져있다.
* 실제적으로 데이터가 저장되는 데이터 파일은 여러개의 익스텐트로 이뤄져있는데, 보통 여러 테이블의 익스텐트를 연속적으로 배열한다.
* 오라클의 블록 크기는 기본적으로 8KB.
* 데이터 I/O의 단위는 블록이다.

\


#### 시퀀셜 액세스

* 논리적, 물리적으로 연결된 순서에 따라 차례로 블록을 읽는 방식. 인덱스 리프 블록은 더블 링크드 리스트라서 헤더,푸터의 주소값으로 이동하는데 이게 시퀀셜 액세스다.
* 랜덤 액세스는 논리적, 물리적인 순서를 따르지 않고, 레코드를 읽기위해 한 블록씩 접근 하는 방식

\


#### DB 버퍼 캐시

* I/O 비효율을 해결하기 위한 데이터 저장 공간
* 공유 메모리 영역이라 다른 프로세스에서 같은 블록을 읽으면 더 빠르게 동작
* 논리적 IO는 SQL 처리과정에서 발생한 총 블록 IO
* 물리적 IO는 SQL 처리과정에서 디스크에 접근한 IO. 보통 메모리 IO보다 10000배 정도 느리다.
* 버퍼 캐시 히트율 = ((1-물리적IO)/논리적 IO) \* 100
* 다만, 우리가 줄여야 하는건 논리적IO 수치다. 물리적 IO 수치는 사실 통제가 불가능한 영역이기 때문에.
* 따라서 버퍼캐시 히트율은 높을 수록 좋지만, 이게 높다고 마냥 좋은 쿼리라고 단정지을 수는 없기 때문.
* 물리적 IO가 발생하면 해당 데이터는 버퍼 캐시에 적재하고 읽는다.
* 인접한 블록을 한번에 나르는 Multi Block IO라고 하더라도, 익스텐트 경계를 넘어서 블록을 나를 수는 없다. 때문에 익스텐트 n번 블록이 마지막이고, n-1블록은 버퍼캐시에 적채되어 있는 경우, Multi Block IO에서도 Single Block IO가 발생할 수 있다.

\


#### 메모리 공유 자원에 대한 액세스 직렬화

* 버퍼캐시는 SGA에 저장되는 공유 자원이기 때문에 어느 프로세스던 접근 가능함.
* 하지만, 공유 자원인지라 동시성 문제가 발생할 수 있어, 접근을 직렬화해야한다. 일종의 세마포어인 셈.
* 이런 직렬화를 위해서 래치(Latch)를 이용한다. Lock인 셈.
* 이런 직렬화 과정에서 경합으로 인한 성능 저하가 발생할 수 있으므로, 이를 줄이기 위해선 논리적 IO 자체를 줄여서 경합 발생 확률을 낮추는 것이 중요함.

\
