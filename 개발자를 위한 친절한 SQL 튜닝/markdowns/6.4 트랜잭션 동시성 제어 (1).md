# 6.4 트랜잭션 동시성 제어

* 비관적 동시성 제어
  * 사용자들이 동시에 데이터를 수정할 것을 전제로 한 사용자가 데이터를 읽는 시점에 Lock 을 걸고 트랜잭션을 완료하기 전까지 다른 사용자가 수정 불가
  * 다만, 동시성이 떨어질 가능성이 있기에 WAIT, NOWAIT 옵션을 사용하여 다른 트랜잭션에 의한 Lock으로 인해 얼마나 대기할지 제어할 수 있다. 혹은 SKIP LOCKED 옵션을 이용하여 Lock이 걸린 레코드는 생략하고 다음 레코드로 이동할 수도 있다. 이 경우 트랜잭션에서 레코드가 제외되더라도 다른 트랜잭션에서 해당 데이터를 다시 처리하고 넘어갈거란 전제가 포함되어 있다.
* 낙관적 동시성 제어
  * 읽는 시점엔 Lock을 걸지 않지만, 데이터를 변경하는 시점엔 이전에 데이터가 이미 변경되었는지 확인함. 동시 트랜잭션에 의한 아노말리를 허용하는 건 아님
  * 데이터를 업데이트 하는 시점에, 같은 트랜잭션에서 읽었던 변경 일시 컬럼을 확인하는 방식으로 동시성 검사 수행

\


*   동시성 제어 없는 낙관적 프로그래밍

    ![Untitled](assets/cb34152b\_Untitled.png)

    * T1에서 T3로 진행 중 공급사가 상품의 가격을 변경할 것이라는 믿음 하에, 동시성을 제어하지 않는 경우가 있다.
    * 격리 레벨이 READ\_COMMIT 수준이라면 충분히 발생할 수 있는 일
*   채번 방식에 따른 INSERT 성능

    * 채번 테이블
      * 별도의 테이블에서 채번 레코드를 관리하는 방식
      * 채번 레코드를 변경하면서 액세스 직렬화가 이뤄서 중복 값 가능성 제거
      * 다른 채번 방식에 비해 성능은 안 좋음
        * 채번 레코드가 수정되고 COMMIT,ROLLBACK 될 때까지 Lock이 걸림
      * 동시 INSERT가 많으면 채번 레코드 뿐 아니라 채번 테이블 블록 자체에도 경합이 발생함
      * 따라서 동시 INSERT가 아주 많은 테이블에는 사실상 사용 불가
    * 시퀀스 오브젝트
      * 성능이 빠른게 장점
      * 채번 테이블과 마찬가지로 중복 레코드 발생에 대한 걱정은 안 해도 됨.
      * 오라클에서 시퀀스 오브젝는 결국 오라클 내부에서 관리하는 채번 테이블
      * 자율 트랜잭션 (논리적 내부 트랜잭션)도 기본 포함됨
      * 신규 데이터를 입력하는 과정에서 결번이 생길 수 있음
        * 다만 결번 자체가 딱히 나쁜 건 아니라서… 중간에 데이터를 삭제하는 경우에도 인조키의 결번은 생길 수 있다.
    * MAX + 1 조회
      * 시퀀스나 채번 테이블을 관리할 필요가 없음.

    \


    * 다만, MySql에선 inno db엔진에서 자체적으로 Lock 을 통한 Auto increment 값에 대한 관리를 해주기 때문에 당장은 이로 인한 문제를 크게 우려하지 않아도 될 것 같다.
    *

    \
